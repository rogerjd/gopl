package chap9

import (
	"fmt"
	"io"
	"net/http"
	"io/ioutil"
	"regexp"
	"net/url"
)

func LinksFromURL(urlb string) ([]string, error) {
	resp, err := http.Get(urlb)
	if err != nil {
	    fmt.Println(err)
	    return nil, err
	}
	fmt.Println(resp, err)
	defer resp.Body.Close() //ref: must close
	res, err := linksFromReader(resp.Body)
	if err != nil {
	    fmt.Println(res, err)
	    return nil, err
	}
	
    fmt.Println("ResolveReference")	    
    base, err := url.Parse(urlb)
	for _, u := range res{
	    x, e := url.Parse(u)
	    if e != nil {
	        fmt.Println(e)	    
	    }
        fmt.Println(base.ResolveReference(x))	    
	}
	
	return res, nil
}

type
    urls []string
    
func (u *urls) AddUnique(url string){
    for _, v := range *u {
        if v == url{
            return
        }
    }
    *u = append(*u, url)
    
}    

func linksFromReader(r io.ReadCloser) ([]string, error) {
//    defer r.Close() //ref: must close
    b, err := ioutil.ReadAll(r) 
    if err != nil {
        fmt.Println(err)
        return nil, err
    }
    fmt.Println(string(b))
    
    rx := regexp.MustCompile(`href="(.*?)"`)
    m := rx.FindAllSubmatch(b, -1)
    for _, m1 := range m {
        fmt.Print(string(m1[0]), " capture group: " + string(m1[1]), "\n")
    }
    println(len(m))
    fmt.Printf("%v\n", m)   
    
    mp := make(map[string]struct{})
    for _, m1 := range m {
        mp[string(m1[1])] = struct{}{}
    }
    
    res := []string{}
    for k, _ := range mp {
        res = append(res, k)
    }
    
    println(len(mp))
    fmt.Printf("%v\n", res)  
    
    unique := urls{}
    for _, m1 := range m {
        unique.AddUnique(string(m1[1]))
    }
    fmt.Println("unique", len(unique))
    
    
	return res, nil
}
